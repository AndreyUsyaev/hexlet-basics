# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `valid_email2` gem.
# Please instead update this file by running `bin/tapioca gem valid_email2`.


# source://valid_email2//lib/valid_email2/dns.rb#3
module ValidEmail2
  class << self
    # source://valid_email2//lib/valid_email2.rb#19
    def allow_list; end

    # source://valid_email2//lib/valid_email2.rb#15
    def deny_list; end

    # source://valid_email2//lib/valid_email2.rb#11
    def disposable_emails; end

    private

    # source://valid_email2//lib/valid_email2.rb#29
    def load_file(path); end

    # source://valid_email2//lib/valid_email2.rb#25
    def load_if_exists(path); end
  end
end

# source://valid_email2//lib/valid_email2.rb#7
ValidEmail2::ALLOW_LIST_FILE = T.let(T.unsafe(nil), String)

# source://valid_email2//lib/valid_email2/address.rb#8
class ValidEmail2::Address
  # @return [Address] a new instance of Address
  #
  # source://valid_email2//lib/valid_email2/address.rb#31
  def initialize(address, dns = T.unsafe(nil)); end

  # Returns the value of attribute address.
  #
  # source://valid_email2//lib/valid_email2/address.rb#9
  def address; end

  # Sets the attribute address
  #
  # @param value the value to set the attribute address to.
  #
  # source://valid_email2//lib/valid_email2/address.rb#9
  def address=(_arg0); end

  # @return [Boolean]
  #
  # source://valid_email2//lib/valid_email2/address.rb#88
  def allow_listed?; end

  # @return [Boolean]
  #
  # source://valid_email2//lib/valid_email2/address.rb#92
  def deny_listed?; end

  # @return [Boolean]
  #
  # source://valid_email2//lib/valid_email2/address.rb#80
  def disposable?; end

  # @return [Boolean]
  #
  # source://valid_email2//lib/valid_email2/address.rb#84
  def disposable_domain?; end

  # @return [Boolean]
  #
  # source://valid_email2//lib/valid_email2/address.rb#72
  def dotted?; end

  # @return [Boolean]
  #
  # source://valid_email2//lib/valid_email2/address.rb#76
  def subaddressed?; end

  # @return [Boolean]
  #
  # source://valid_email2//lib/valid_email2/address.rb#45
  def valid?; end

  # @return [Boolean]
  #
  # source://valid_email2//lib/valid_email2/address.rb#64
  def valid_address?; end

  # @return [Boolean]
  #
  # source://valid_email2//lib/valid_email2/address.rb#52
  def valid_domain?; end

  # @return [Boolean]
  #
  # source://valid_email2//lib/valid_email2/address.rb#96
  def valid_mx?; end

  # @return [Boolean]
  #
  # source://valid_email2//lib/valid_email2/address.rb#103
  def valid_strict_mx?; end

  private

  # @return [Boolean]
  #
  # source://valid_email2//lib/valid_email2/address.rb#140
  def address_contain_multibyte_characters?; end

  # @return [Boolean]
  #
  # source://valid_email2//lib/valid_email2/address.rb#112
  def disposable_mx_server?; end

  # @return [Boolean]
  #
  # source://valid_email2//lib/valid_email2/address.rb#122
  def domain_is_in?(address_domains, domain_list); end

  # TODO: (PS) keep this for backward compatibility with the test setup described in the reamde
  #
  # @return [Boolean]
  #
  # source://valid_email2//lib/valid_email2/address.rb#117
  def mx_server_is_in?(domain_list); end

  # @return [Boolean]
  #
  # source://valid_email2//lib/valid_email2/address.rb#148
  def null_mx?; end

  class << self
    # source://valid_email2//lib/valid_email2/address.rb#23
    def permitted_multibyte_characters_regex; end

    # source://valid_email2//lib/valid_email2/address.rb#27
    def permitted_multibyte_characters_regex=(val); end

    # source://valid_email2//lib/valid_email2/address.rb#15
    def prohibited_domain_characters_regex; end

    # source://valid_email2//lib/valid_email2/address.rb#19
    def prohibited_domain_characters_regex=(val); end
  end
end

# source://valid_email2//lib/valid_email2/address.rb#12
ValidEmail2::Address::DEFAULT_RECIPIENT_DELIMITER = T.let(T.unsafe(nil), String)

# source://valid_email2//lib/valid_email2/address.rb#13
ValidEmail2::Address::DOT_DELIMITER = T.let(T.unsafe(nil), String)

# source://valid_email2//lib/valid_email2/address.rb#11
ValidEmail2::Address::PROHIBITED_DOMAIN_CHARACTERS_REGEX = T.let(T.unsafe(nil), Regexp)

# source://valid_email2//lib/valid_email2.rb#6
ValidEmail2::DENY_LIST_FILE = T.let(T.unsafe(nil), String)

# source://valid_email2//lib/valid_email2.rb#8
ValidEmail2::DISPOSABLE_FILE = T.let(T.unsafe(nil), String)

# source://valid_email2//lib/valid_email2/dns.rb#4
class ValidEmail2::Dns
  # @return [Dns] a new instance of Dns
  #
  # source://valid_email2//lib/valid_email2/dns.rb#20
  def initialize(dns_timeout = T.unsafe(nil), dns_nameserver = T.unsafe(nil)); end

  # source://valid_email2//lib/valid_email2/dns.rb#29
  def a_servers(domain); end

  # source://valid_email2//lib/valid_email2/dns.rb#25
  def mx_servers(domain); end

  private

  # source://valid_email2//lib/valid_email2/dns.rb#39
  def fetch(domain, type); end

  # source://valid_email2//lib/valid_email2/dns.rb#35
  def prune_cache; end

  # source://valid_email2//lib/valid_email2/dns.rb#65
  def resolv_config; end

  class << self
    # source://valid_email2//lib/valid_email2/dns.rb#16
    def clear_cache; end

    # source://valid_email2//lib/valid_email2/dns.rb#10
    def prune_cache; end
  end
end

# source://valid_email2//lib/valid_email2/dns.rb#6
ValidEmail2::Dns::CACHE = T.let(T.unsafe(nil), Hash)

# source://valid_email2//lib/valid_email2/dns.rb#8
class ValidEmail2::Dns::CacheEntry < ::Struct
  # Returns the value of attribute cached_at
  #
  # @return [Object] the current value of cached_at
  def cached_at; end

  # Sets the attribute cached_at
  #
  # @param value [Object] the value to set the attribute cached_at to.
  # @return [Object] the newly set value
  def cached_at=(_); end

  # Returns the value of attribute records
  #
  # @return [Object] the current value of records
  def records; end

  # Sets the attribute records
  #
  # @param value [Object] the value to set the attribute records to.
  # @return [Object] the newly set value
  def records=(_); end

  # Returns the value of attribute ttl
  #
  # @return [Object] the current value of ttl
  def ttl; end

  # Sets the attribute ttl
  #
  # @param value [Object] the value to set the attribute ttl to.
  # @return [Object] the newly set value
  def ttl=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://valid_email2//lib/valid_email2/dns.rb#5
ValidEmail2::Dns::MAX_CACHE_SIZE = T.let(T.unsafe(nil), Integer)

# source://valid_email2//lib/valid_email2/email_validator.rb#7
class ValidEmail2::EmailValidator < ::ActiveModel::EachValidator
  # source://valid_email2//lib/valid_email2/email_validator.rb#8
  def default_options; end

  # source://valid_email2//lib/valid_email2/email_validator.rb#70
  def error(record, attribute); end

  # source://valid_email2//lib/valid_email2/email_validator.rb#58
  def sanitized_values(input); end

  # source://valid_email2//lib/valid_email2/email_validator.rb#12
  def validate_each(record, attribute, value); end
end
